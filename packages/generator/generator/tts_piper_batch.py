"""
Generate TTS WAV files from outputs/plan.json using Piper on Windows.

- Supports both Plan v1 (keys: dialogue) and Plan v2 (keys: dialogue_text, verse{ref,text}, mode).
- For v2, speech = [verse.text (with ref)] + dialogue_text (if present), then sanitized.
- Sequential execution. One WAV per clip: outputs/audio/clipN.wav.

Usage:
  python tts_piper_batch.py
Optional:
  python tts_piper_batch.py --plan outputs/plan.json --exe "D:\\tools\\piper\\piper.exe" --model "D:\\tools\\piper\\models\\en_GB-northern_english_male-medium.onnx" --outdir outputs/audio
"""

from __future__ import annotations
import argparse
import json
import os
import subprocess
from pathlib import Path
import sys

# --- Defaults (env overrides supported) ---
DEFAULT_PLAN = Path("outputs/plan.json")
DEFAULT_PIPER_EXE = Path(os.getenv("PIPER_EXE", r"packages\generator\generator\tools\piper\piper.exe"))
DEFAULT_MODEL = Path(os.getenv("PIPER_MODEL", r"packages\generator\generator\tools\piper\models\en_GB-alan-low.onnx"))
DEFAULT_OUTDIR = Path("outputs/audio")


def run_piper(text: str, exe: Path, model: Path, wav_out: Path) -> None:
    """Call Piper with the given text → write to wav_out."""
    wav_out.parent.mkdir(parents=True, exist_ok=True)
    cmd = [str(exe), "-m", str(model), "-f", str(wav_out)]
    subprocess.run(cmd, input=text.encode("utf-8"), check=True)


def load_plan(plan_path: Path) -> dict:
    """Load the JSON plan generated by api_call.py."""
    try:
        with plan_path.open("r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Plan not found: {plan_path}", file=sys.stderr)
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"Invalid JSON in plan: {e}", file=sys.stderr)
        sys.exit(1)


def sanitize_dialogue(text: str) -> str:
    """
    Minimal cleanup before TTS:
    - strip whitespace
    - collapse internal whitespace/newlines
    """
    return " ".join((text or "").strip().split())


def clip_to_speech_v1(clip: dict) -> str:
    """Plan v1 → use 'dialogue' as-is."""
    return sanitize_dialogue(clip.get("dialogue", ""))


def clip_to_speech_v2(clip: dict) -> str:
    """
    Plan v2 → concatenate verse.text (+ ref) and dialogue_text when present.
    Example: "<verse text> (Book ch:vs). <dialogue_text>"
    """
    parts = []
    verse = clip.get("verse") or None
    if verse and verse.get("text"):
        ref = verse.get("ref", "").strip()
        if ref:
            parts.append(f"{verse['text']} ({ref}).")
        else:
            parts.append(verse["text"])
    if clip.get("dialogue_text"):
        parts.append(clip["dialogue_text"])
    return sanitize_dialogue(" ".join(parts))


def clip_to_speech(clip: dict) -> str:
    """Dispatch based on present keys."""
    if "dialogue_text" in clip or "verse" in clip:
        return clip_to_speech_v2(clip)
    return clip_to_speech_v1(clip)


def main() -> None:
    ap = argparse.ArgumentParser(description="Batch-generate WAV files from plan.json using Piper")
    ap.add_argument("--plan", type=Path, default=DEFAULT_PLAN, help="Path to plan.json")
    ap.add_argument("--exe", type=Path, default=DEFAULT_PIPER_EXE, help="Path to piper.exe")
    ap.add_argument("--model", type=Path, default=DEFAULT_MODEL, help="Path to .onnx voice model")
    ap.add_argument("--outdir", type=Path, default=DEFAULT_OUTDIR, help="Output directory for WAV files")
    args = ap.parse_args()

    if not args.exe.exists():
        print(f"piper.exe not found: {args.exe}", file=sys.stderr)
        sys.exit(1)
    if not args.model.exists():
        print(f"Voice model not found: {args.model}", file=sys.stderr)
        sys.exit(1)

    plan = load_plan(args.plan)
    clips = plan.get("clips", [])
    if not clips:
        print("Plan has no clips.", file=sys.stderr)
        sys.exit(1)

    generated = []
    for clip in clips:
        idx = clip.get("index")
        speech_text = clip_to_speech(clip)
        if not speech_text:
            print(f"Clip {idx}: empty speech; skipping.", file=sys.stderr)
            continue

        wav_path = args.outdir / f"clip{idx}.wav"
        print(f"[{idx}/{len(clips)}] TTS → {wav_path.name}")
        try:
            run_piper(speech_text, args.exe, args.model, wav_path)
            generated.append(wav_path)
        except subprocess.CalledProcessError as e:
            print(f"Clip {idx}: Piper failed with exit code {e.returncode}", file=sys.stderr)
            sys.exit(e.returncode)

    if generated:
        print(f"Done. Wrote {len(generated)} files → {args.outdir.resolve()}")
    else:
        print("No files generated.", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
